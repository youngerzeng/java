# 面向对象

[TOC]

### 面向对象三大特征

- **封装**：把对象的属性与方法的实现细节隐藏，仅对外提供公共访问方式

  - 变量： private 修饰，这就是变量的封装


  - 方法：也是一种封装，封装了多条代码
  - 类：也是一种封装，封装了多个方法
- **继承(extends)**
- **多态**

> 栈存放局部变量，对象的引用

> 堆存放new出来的东西
>
> 构造方法目的：为属性赋值，构造方法也是重载
>
> 匿名对象：只使用一次的对象，只在堆内存中开辟空间
>
> this:当前对象，调用类的属性，构造器，方法

### 构造方法

- 创建对象，在new的同时给成员变量赋值,给对象属性进行初始化。

###this关键字

- 本类对象的引用
- 当创建对象的时候，this存在的
- 区别同名的成员变量与局部变量（this.成员变量）

### super关键字

- 在创建子类对象时，必须调用父类的构造方法，因为子类中所有构造方法的第一行有默认的隐式super();
- 子类会继承父类中的内容，所以子类在初始化时，必须先到父类中去执行父类的初始化动作。这样，才可以使用父类中的内容。
- 当父类中没有空参数构造方法时，子类的构造方法必须有显示的super语句，否则报错
- this()或者super(),只能定义在构造方法的第一行，因为初始化动作要先执行。

### private关键字

- 修饰成员内容包括成员方法和成员变量

### static关键字

- static：静态修饰符，所有对象共享
- static修饰成员变量：该变量属于类，不属于某个对象，其中一个对象将static成员变量值进行了修改，其他对象中的static成员变量值跟着改变，即多个对象共享同一个static成员变量）

static修饰方法：类方法，静态的方法只能访问静态的成员

static调用限制：

- 非static的方法可以调用static的属性或方法的
- static的方法不能调用非static类型的属性或方法的。
- 因为不需要实例就可以访问static方法，因此static方法内部不能有this。
- 重载的方法需要同时为static的或者非static的

多态中的静态方法：,编译看父类,运行仍然看父类。因为静态和对象没有关系，属于静态绑定。

静态常量：public static final修饰，变量名用全部大写，多个单词使用下划线连接

接口中的每个成员变量都默认使用public static final修饰

###final关键字

- **final 修饰类**：不可以被继承 
- final修饰方法：不可以被覆盖
- final局部变量：
  - final修饰基本数据类型变量：称为常量，这些变量只能赋值一次
  - final修饰引用数据类型：地址值不能更改，地址内的对象属性值可以修改
- final修饰成员变量：需要在创建对象前赋值，否则报错

### 成员变量和局部变量的区别

- 区别一：定义的位置不同
  - 成员变量：类中的变量
  - 局部变量：方法中或者{}语句的变量
- 区别二：在内存中的位置不同
  - 成员变量：存储在堆内存的对象中
  - 局部变量：存储在栈内存的方法中
- 区别三：声明周期不同
  - 成员变量：随着对象的出现而出现在堆中，随着对象的消失而从堆中消失
  - 局部变量：随着方法的运行而出现在栈中，随着方法的弹栈而消失
- 区别四：初始化不同
  - 成员变量因为在堆内存中，所有默认的初始化值
  - 局部变量没有默认的初始化值

### 匿名对象

- 只有创建对象的语句，却没有把对象地址值赋值给某个变量，只能使用一次。

### 内部类

内部类：将类写在其他类的内部，可以写在其他类的成员位置和局部位置

在描述事物时，若一个事物内部还包含其他可能包含的事物，就可以使用内部类

- 成员内部类：定义在外部类中的成员位置。与类中的成员变量相似，可通过外部类对象进行访问

  `外部类名.内部类名 变量名 = new 外部类名().new 内部类名();`

- 局部内部类，定义在外部类方法中的局部位置。与访问方法中的局部变量相似，可通过方法中创建内部类对象，调用外部类方法进行访问进行访问.

- 匿名内部类：局部内部类的一种， 临时定义某一指定类型的子类， 定义后即刻创建刚刚定义的这个子类的对象

### 代码块

- 普通代码块：直接在 **方法或是语句** 中定义的代码块
- 构造代码块：直接写在 **类** 中的代码块
  - 构造块优先构造方法执行，每当一个新的实例化对象产生时，都会调用构造块，会调用多次。
- 静态代码块：使用static关键字声明的代码块
  - 在主类中定义的静态块将优先于主方法执行，而且可以发现静态块优先于构造块执行，而且只执行一次。
- 同步代码块

```java
public class Fu {
	{
		System.out.println("03父类的非静态代码块");
	}	
	static{
		System.out.println("01父类的静态代码块");
	}	
	public Fu(){
		System.out.println("04父类的构造代码块");
	}
}
public class Zi extends Fu{ 
	{
		System.out.println("05子类的非静态代码块");
	}
	static {
		System.out.println("02子类的静态代码块");
	}
	public Zi(){
		System.out.println("06子类的构造代码块");
	}
}
public class TestDemo {	
	@Test
	public void fun1(){
		Zi fu = new Zi();		
	}
}
```



### 单例模式

- 单例模式-饿汉式

  ```java
  public class Singleton {
  	private static Singleton instance = new Singleton();	
  	private Singleton(){}
  	
  	public static Singleton getInstance(){
  		return instance;
  	}
  }
  ```

- 单例模式-懒汉式

  ```java
   class Singleton2{
      private static Singleton2 instance = null;
      private Singleton2(){}
      public static Singleton2 getInstance(){
          if(instance == null){
              instance = new Singleton2();
          }
          return instance;
      }
  }

  ```

  ​


### 继承 (extends)

- 子类会自动拥有父类所有非private修饰的属性和方法
- 类只支持单继承，不允许多继承
- 成员变量：  先使用子类,子类自己没有调用的父类
- 成员方法:  先使用子类,子类自己没有调用的父类
- 重写：子类中出现与父类一模一样的方法时，会出现覆盖操作，也称为override重写、复写或者覆盖
- 子类方法抛出的异常不能大于父类被重写方法的异常

**重写**：父类的功能满足不了需求时，就需要子类重写父类的方法

>a:权限:  子类方法权限 >=  父类方法权限。public>默认=protected>private
>
>b:方法的方法名和参数列表都要一样。
>    返回值： 基本数据类型,方法返回值类型必须相同
>     		    引用数据类型,返回值类型可以相同或者子类方法的返回值类型是父类方法返回值类型的子类

重载和重写的区别：

- 重载：方法名称相同,参数的类型，个数和顺序不同

  重写：方法名称、参数的类型、返回值类型全部相同

- 重载：对权限没有要求

  重写：被重写的方法不能拥有更严格的权限

- 重载：发生在一个类中

  重写：发生在继承类中

### 抽象类

抽象类：abstract class 类名 

抽象方法：public abstract 返回值类型 方法名(参数);

> 结合继承使用，抽取子类中所拥有的共性

- 抽象方法一定要定义在抽象类中。
- 抽象类不可以直接创建对象
- 只有覆盖了抽象类中所有的抽象方法后，其子类才可以创建对象。否则该子类还是一个抽象类。
- 抽象类一定是个父类
- 抽象类中可以不定义抽象方法，意义在于不让该类创建对象,方法可以直接让子类去使用 (适配器设计模式)
- private私有无法继承无法覆盖，abstract既要子类去实现这个方法,互相矛盾

 ### 接口

* **接口(interface)**:是功能的集合，这样将功能的定义与实现分离，优化了程序设计。请记住：一切事物均有功能，即一切事物均有接口 

**接口的实现类(implements)**:

- 非抽象类重写该抽象方法，抽象类可以不重写接口中的抽象方法。

* 接口成员变量 :  接口中可以定义变量，public static final 所以接口中的变量也称之为常量，其值不能改变。


* 接口成员方法 :public abstract,子类必须覆盖掉接口中所有的抽象方法后，子类才可以实例化。否则子类是一个抽象类。
* 接口的体现：解决多继承的弊端。将多继承这种机制在java中通过多实现完成了。

- 父类中定义的事物的基本功能。接口中定义的事物的扩展功能。

 接口和抽象类区别总结
 	相同点:
		都位于继承的顶端,用于被其他类实现或继承;
		都不能直接实例化对象;
		都包含抽象方法,其子类都必须覆写这些抽象方法;
	区别:
		抽象类为部分方法提供实现,接口只能包含抽象方法;
		一个类只能继承一个直接父类(可能是抽象类),却可以实现多个接口;
		抽象类是这个事物中应该具备的你内容, 继承体系是一种 is..a关系
		接口是这个事物中的额外内容,继承体系是一种 like..a关系

二者的选用:
	优先选用接口,尽量少用抽象类;
	需要定义子类的行为,又要为子类提供共性功能时才选用抽象类;

### 多态

多态： 就是父类的引用变量指向子类对象 . fu f = new zi();

* C: 多态成员变量
  编译时期：参考的是引用型变量所属的类中是否有被调用的成员变量。没有，编译失败。
  运行时期：也是调用引用型变量所属的类中的成员变量。
  `编译运行看左边。`		 


* E: 多态成员方法
  编译时期：参考引用变量所属的类，如果没有类中没有调用的方法，编译失败。
  运行时期：参考引用变量所指的对象所属的类，并运行对象所属类中的成员方法。
  `编译看左边，运行看右边。`

**instanceof**  :判断某个对象是否属于某种数据类型。如学生的对象属于学生类，学生的对象也属于人类

`boolean flag = p1 instanceof Student; //flag结果为true`

向上转型：当有子类对象赋值给一个父类引用时，便是向上转型，多态本身就是向上转型的过程。		`父类类型  变量名 = new 子类类型();`

 向下转型：一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用转为子类引用，这个过程是向下转型。如果是直接创建父类对象，是无法向下转型的！		`子类类型 变量名 = (子类类型) 父类类型的变量;`

*  多态的好处和弊端
  * 隐藏了子类类型，提高了代码的扩展性。
  * 只能使用父类共性的内容，而无法使用子类特有功能，功能有限制。


* C 多态总结:

  - 当不需要面对子类类型时，通过提高扩展性，或者使用父类的功能就能完成相应的操作，这时就可以使用向上转型.


  - 当要使用子类特有功能时，就需要使用向下转型。
  - 向下转型的好处：可以使用子类特有功能。
  - 弊端是：需要面对具体的子类对象；在向下转型时容易发生ClassCastException类型转换异常。在转换之前必须做类型判断。

  	`if( !a instanceof Dog){…}`

###权限修饰符

|                        | public | protected | default | private |
| ---------------------- | :----: | :-------: | :-----: | :-----: |
| 同一类中               |   √    |     √     |    √    |    √    |
| 同一包中(子类与无关类) |   √    |     √     |    √    |         |
| 不同包的子类           |   √    |     √     |         |         |
| 不同包中的无关类       |   √    |           |         |         |



- 在日常开发过程中，编写的类、方法、成员变量的访问
- 要想仅能在本类中访问使用private修饰；
- 要想本包中的类都可以访问不加修饰符即可；
- 要想本包中的类与其他包中的子类可以访问使用protected修饰
- 要想所有包中的所有类都可以访问使用public修饰。
- 注意：如果类用public修饰，则类名必须与文件名相同。一个文件中只能有一个public修饰的类

###修饰符总结

常用来修饰类、方法、变量的修饰符如下：

- public 权限修饰符，公共访问, 类,方法,成员变量
- protected 权限修饰符，受保护访问, 方法,成员变量
- 默认什么也不写 也是一种权限修饰符，默认访问, 类,方法,成员变量
- private 权限修饰符，私有访问, 方法,成员变量
- static 静态修饰符  方法,成员变量
- final 最终修饰符   类,方法,成员变量,局部变量
- abstract 抽象修饰符  类 ,方法

不能同时使用的修饰符

- abstract与private不能同时使用；
- abstract与static不能同时使用；
- abstract与final不能同时使用

修饰类：public、默认的、final、abstract。使用最多的是 public关键字

修饰成员变量：public 、protected 、默认的、private 、final、static 。

			   最多的是 private。

修饰构造方法：public 、protected 、默认的、private ，使用最多的是public

修饰成员方法：public 、protected 、默认的、private 、final、static 、abstract

			   使用最多的是public

**注**：

- 方法参数为抽象类类型时，要传入一个实现抽象类所有抽象方法的子类对象
- 抽象类作为方法返回值的情况，这时需要返回一个实现抽象类所有抽象方法的子类对象。
- 当遇到方法参数为接口类型时，那么该方法要传入一个接口实现类对象。
- 当遇到方法返回值是接口类型时，那么该方法需要返回一个接口实现类对象。