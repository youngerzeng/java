# 深入理解Java虚拟机

[TOC]

## 第一章：走进Java

### 1.1 java概述

java技术体系：

- java程序设计语言
- 各种硬件平台上的java虚拟机
- Class 文件格式
- Java API类库
- 来自商业机构和开源社区的第三方Java类库

**JDK**：java程序设计语言、java虚拟机、Java  API 这三部分统称为  JDK（Java Development Kit）。

**JRE：**Java API类库中的 Java SE API 子集和 Java虚拟机这两部分统称为JRE（Java Runtime Environment）.

###1.2 java发展史

1995.5.23	java 1.0 版本发布

1998.12.4	JDK 1.2发布

1999.4.27	HopSPot 虚拟机发布

2000.5.8		JDK 1.3发布

2002.2.13	JDK 1.4发布

2004.9.30	JDK 1.5发布。改进：自动装箱、泛型、动态注解、枚举、可变长参数、遍历循环

2006.11.13	Sun公司宣布将 Java开源

2006.12.11	JDK 1.6发布。提供动态语言支持、提供编译 API和微型 HTTP服务器 API等。同时对Java 虚拟机内部		        	                      有很大改进，包括锁 与同步、垃圾收集、类加载。

2009.4.20	Oracle收够Sun公司

2011.7.28	JDK 1.7发布。改进：提供新的 G1收集器、加强对非 Java语言的调用支持、升级类加载架构

2013.9		JDK 1.8 发布。 改进：Lambda表达式

HotSpot：目前使用范围最广的 Java虚拟机

**混合语言**

Clojure、JRuby、Groovy等基于JVM的语言与Java混合编程。

`361词`

## 第二章：Java内存区域与内存溢出异常

### 2.2运行时数据区域

![Java虚拟机运行时数据区](C:\Users\youngerzeng\Desktop\JavaSE笔记\img\Java虚拟机运行时数据区.png)

####2.2.1 程序计数器（Program Counter Register）

- 概述：一块较小的内存空间，可以看作是当前线程所执行的字节码的 **行号指示器**
- 作用：通过改变计数器的值来选取下一条需要执行的字节码指令。（分支、循环、跳转、异常处理、线程恢复等）基础功能都依赖与其完成。
- 特点：
  1.线程私有，每条线程都需要有一个独立的程序计数器。
  2.无内存溢出：如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在 执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。**此内存区域是唯一一个在 Java 虚拟机程序规范中没有规定任何 OutOfMemoryError 情况的区域。**

####2.2.2  Java 堆（Java Heap）

-  Java 虚拟机所管理的内存中最大的一块区域。
- 唯一的目的存放对象实例。
- 被所有线程共享，在虚拟机启动时创建。
- 异常：OutOfMemoryError


- 内存：可物理上不连续，逻辑上连续。在实现时，既可以实现成固定大小的，也可以是可扩展的，当前主流的虚拟机都是按照可扩展来实现的（通过 `-Xmx` 和 `-Xms` 控制）。

还可细分为：新生代和老年代

再细致点分：Eden空间、From Survivor空间、To Survivor空间

> Reminde 
> 随着 JIT 编译器的发展与逃逸分析技术成熟，**栈上分配**、**标量替换** 等优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也变得不那么绝对了。

####2.2.3  Java 虚拟机栈（Java Virtual Machine Stacks）

- 概述：描述 Java 方法执行的内存模型，每个方法从调用直至执行的过程，对应着一个 **栈帧** 在虚拟机栈中入栈到出栈的过程。
- 作用：每个方法在执行的同时都会创建一个栈帧，用户存储局部变量表、操作栈数、动态链接、方法出口等信息，方法调用到完成，对应着一个栈帧在虚拟机栈中入栈到出栈的过程
- 特点：
  1.线程私有。
  2.生命周期与线程相同。

#####  - 局部变量表

- 概述：存放了编译期间可知的各种基本数据类型（8种）、对象引用、returnAddress 类型（指向一条字节码指令的地址）。
- 占用空间：64位长度的 `long` 和 `double` 占用 2 个局部变量空间
- 分配时机：在编译期间完成分配，当进入一个方法时，这个方法所需要在帧中分配多大的局部变量空间是完全确定的，**在方法运行期间不会改变局部变量表的大小。**



#####  - 对象引用

- 概述：reference 类型，指向一条字节码指令的地址，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置。

##### - 异常

- StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度
- OutOfMemoryError无法申请到足够的内存

####2.2.4  本地方法栈（Native Method Stack）

- 概述：与虚拟机栈类似，是为虚拟机使用到的 Native 方法服务的内存区域。

- 区别：

  虚拟机栈：为虚拟机执行 Java 方法（字节码）服务。

  本地方法栈：为虚拟机使用到的 Native 方法服务。

- 异常：与虚拟机栈一致。

####2.2.5  方法区（Method Area）

- 作用：存储已被虚拟机加载的（**类信息、常量、静态变量、即时编译器编译后的代码**）等数据。

- 特点：线程共享。

- 异常

  OutOfMemoryError：  当方法区无法满足内存分配需求时，抛出该异常。


- 内存：Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存空间和可以选择固定大小或者可扩展外，**可以选择不实现垃圾收集**。

> 相对而言，垃圾收集行为在这个区域是比较少出现的，这个区域的内存回收目标主要是针对 **常量池的回收** 和 **类型的卸载**。

####2.2.6  运行时常量池（Runtime Constant Pool）

- 概述：方法区的一部分。Class 文件中除了有类的（版本、字段、方法、接口）等描述信息外，还有一项信息就是常量池。
- 作用：用于存放编译器生成的各种 **字面量** 和 **符号引用**。
- 动态性：运行期间也可以将新的常量放入池中，这种特性用的比较广泛的便是 String 类的 `intern()` 方法。
- 异常：OutOfMemoryError：常量池无法再申请到内存时

####2.2.7 - 直接内存（Direct Memory）

- 概述：不是虚拟机运行时数据区的一部分

- 作用：在 JDK1.4 中新加入了 NIO（New Input/Output） 类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。避免了在 Java 堆和 Native 堆中来回复制数据。

- 异常：

  OutOfMemoryError：受到物理内存限制，动态扩展时无法申请到内存时

###2.3 HotSpot 虚拟机对象探秘

>  阐述HotSpot 虚拟机堆中对象分配、布局和访问的全过程。

####2.3.1 - 对象的创建

- 通过 `new` 关键字，创建对象分以下几个步骤：

**类加载**

- 检查指令参数是否能在常量池中定位到一个类的符号引用，检查这个符号引用代表的类是否已被加载、解析和初始化过。没有就执行类加载

**分配内存**

- 为对象分配内存区域(指针碰撞 & 空闲列表)
  - 指针碰撞： Java 堆中内存绝对规整，用过内存和空闲内存分两边，中间放指针指示器，分配内存就把指针向空闲那边挪动一段与对象大小相等的距离。
  - 空闲列表（Free List）： Java 堆中内存不是规整就无法指针碰撞，虚拟机就必须维护一个列表，记录可用的内存块，分配时从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。

> 选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用 Serial、ParNew 等带 Compact 过程的收集器时，系统采用的分配算法是指针碰撞，而使用 CMS 这种基于 Mark-Sweep 算法的收集器时，通常采用空闲列表。

**同步控制**

- 线程安全（1.对分配内存空间的动作同步；2.本地分配缓冲TLAB）
  - 对分配内存空间的动作进行同步处理，采用 **CAS 配上失败重试** 的方式保证更新操作的原子性。
- 方案二：将内存分配的动作按照线程划分在不同的空间中进行，每个线程在 Java 堆中预先分配一小块内存，称为 **本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）** 。哪个线程需要分配内存，就在哪个线程的 TLAB 上分配，只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定。通过 `-XX:+/-UseTLAB` 参数设定是否使用 TLAB。

**初始化**

- 内存空间初始化为零值（不包括对象头），如果使用 TLAB，这一过程就可以提前至 TLAB 分配时进行。作用：保证对象的实例字段不赋初值就直接使用

**对象头（Object Header）**

- 为对象头数据进行设置。（对象的实例类、类的元数据信息的地址、对象的哈希码、对象的 GC 分代年龄）

**init**

- 所有的字段还为零值。 调用 `<init>` 方法，将对象按照我们的意愿进行初始化，这样一个真正的对象才算完全产生。


####2.3.2 对象的内存布局

> 对象在内存中存储的布局：对象头，实例数据，对齐填充

**对象头（Header）**

> HotSpot 虚拟机的对象头包括两部分信息，**存储自身的运行时数据（Mark Word）** 和 **类型指针。**

**运行时数据**

- 概述：用于存储对象自身的运行时数据，如（HashCode、GC 分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳）
- 内存：对象需要存储的运行时数据很多，其实已经超出了 32位、64位 Bitmap 结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word 被设计成一个 **非固定的数据结构** 以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。
- HotSpot 虚拟机对象头 Mark Word 表如下 👇

| 存储内容                              | 标志位 | 状态               |
| ------------------------------------- | ------ | ------------------ |
| 对象哈希码、对象分代年龄              | 01     | 未锁定             |
| 指向锁记录的指针                      | 00     | 轻量级锁定         |
| 指向重量级锁的指针                    | 10     | 膨胀（重量级锁定） |
| 空（不需要记录信息）                  | 11     | GC 标记            |
| 偏向线程 ID、偏向时间戳、对象分代年龄 | 01     | 可偏向             |

**第二部分：类型指针**

- 概述：即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

> Reminder 👉
> 并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据并不一定要经过对象本身。

- 数组对象：如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是从数组的元数据中却无法确定数组的大小。

**实例数据（Instance Data）**

- 概述：这部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。
- 存储顺序：这部分的存储顺序会受到虚拟机 **分配策略参数（FieldsAllocationStyle）** 和字段在 Java 源码中定义顺序的影响。HotSpot 虚拟机默认的分配策略为 longs/doubles => ints => shorts/chars => bytes/booleans => oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，**在父类中定义的变量会出现在子类之前**。如果 `CompactFields` 参数值为 true（默认为 true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。

**对齐填充（Padding）**

- 概述：不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。
- 原理：由于 HotSpot VM 的自动内存管理系统要求 **对象起始地址必须是 8 字节的整倍数**，换句话说，就是对象的大小必须是 8 字节的整倍数。而对象头部分正好是 8 字节的整倍数（ 1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

####2.2.3  对象的访问定位

- 概述：建立对象是为了使用对象，我们的 Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。由于 reference 类型在 Java 虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以 **对象访问方式也是取决于虚拟机实现而定的**。目前主流的访问方式有两种。
- **句柄访问**：Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息
- **直接指针**：Java 堆对象的布局中必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址
- 句柄访问：使用句柄访问的最大好处就是 reference 中存储的是 **稳定的** 句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。
- 指针访问：使用直接访问最大的好处就是 **速度快**，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。

> Sun HotSpot 使用的是第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。

##第三章：垃圾收集器与内存分配策略

###3.1概述

> 程序计数器、虚拟机栈、本地方法栈 3 个区域随线程生灭(因为是线程私有)，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期才知道那些对象会创建，这部分内存的分配和回收都是动态的，垃圾回收期所关注的就是这部分内存。

###3.2对象已死吗

####3.2.1引用计数法

> 给对象中添加一个引用计数器，每当有一个地方引用它时计数器值就加1，当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能被使用。

- 实现简单、判定效率高
- 无法解决循环引用的问题
- 主流虚拟机没有采用

####3.2.2可达性分析算法

> 通过一系列称作“GC Roots”的对象作为起始点，向下搜索，搜索走过的路径成为引用链，当一个对象到GC Roots没有任何引用链相连，则证明不可用

**可作为GC Roots的对象**:

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI(即一般所说的native方法)引用的对象

####3.2.3再谈引用

- 强引用:类似于 `Object obj = new Object();` 创建的，只要强引用在就不回收。
- 软引用:SoftReference 类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。
- 弱引用:WeakReference 类实现弱引用。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。
- 虚引用:PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

####3.2.4生存还是死亡

- 不可达对象要经历两次标记才宣告死亡
- 发现没有与 GC Roots 相连接的引用链，第一次标记筛选判断是否需要执行finalize()方法
- 当对象没有覆盖finalize()或者已经被虚拟机调用，则不需要执行
- 有必要执行，则放到F-Queue的队列中，稍后由虚拟机自建的、低级别的线程Finalizer去执行———触发操作，不保证运行结束
- finalize()方法是对象逃脱死亡的最后一次机会
- 如果对象要在 finalize() 中成功拯救自己 —— 只要重新与引用链上的任何一个对象简历关联**即可**

> 即使在可达性分析算法中不可达的对象，它们暂时出于“缓刑”阶段，一个对象的真正死亡至少要经历两次标记过程：如果对象在进行中可达性分析后发现没有与 GC Roots 相连接的引用链，那他将会被第一次标记并且进行一次筛选，筛选条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。
>
> 如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象竟会放置在一个叫做 F-Queue 的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。这里所谓的“执行”是指虚拟机会出发这个方法，并不承诺或等待他运行结束。finalize() 方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize() 中成功拯救自己 —— 只要重新与引用链上的任何一个对象简历关联即可。
>
> finalize() 方法只会被系统自动调用一次。

###3.2.5回收方法区

回收废弃常量：判断没有该常量的引用。

回收无用的类：要以下三个条件都满足

- 该类所有的实例都已经回收，也就是 Java 堆中不存在该类的任何实例
- 加载该类的 ClassLoader 已经被回收
- 该类对应的 java.lang.Class 对象没有任何地方呗引用，无法在任何地方通过反射访问该类的方法

###3.3 垃圾收集算法

####3.3.1标记-清除算法

> 算法分为标记和清除两个阶段，首先标出需要回收的对象，标记完成后统一回收

**不足：**效率，标记和清除效率都不高；空间，产生内存碎片

####3.3.2复制算法

> 将内存按容量分为大小相等的两块，每次只使用一块
>
> 当一块用完了，将活着的对象复制到另一块上，然后把已使用过的内存清理掉

**不足**：内存缩小一半，造成内存浪费

> 解决前一种方法的不足，但是会造成空间利用率低下。因为大多数新生代对象都不会熬过第一次 GC。所以没必要 1 : 1 划分空间。可以分一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另一块 Survivor 上，最后清理 Eden 和 Survivor 空间。大小比例一般是 8 : 1 : 1，每次浪费 10% 的 Survivor 空间。但是这里有一个问题就是如果存活的大于 10% 怎么办？这里采用一种分配担保策略：多出来的对象直接进入老年代。

####3.3.3标记-整理算法

适合老年代

> 过程与 ”标记-清除“ 算法一样，不同的是不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存

####3.3.4分代收集算法

> 根据存活对象划分几块内存区，一般是分为新生代和老年代。然后根据各个年代的特点制定相应的回收算法

新生代：每次垃圾回收都有大量对象死去，只有少量存活，选用`复制算法`比较合理。

老年代：老年代中对象存活率较高、没有额外的空间分配对它进行担保。所以必须使用 `标记 —— 清除`或者 `标记 —— 整理` 算法回收。

###3.4HotSpot的算法实现

###3.5垃圾收集器

![HopSpot虚拟机的垃圾收集器](C:\Users\youngerzeng\Desktop\JavaSE笔记\img\垃圾收集器.png)



####3.5.1 Serial 收集器

- 最基本，发展最悠久的
- 单线程收集器，使用一个 CPU 或一条收集线程去完成收集工作
- 暂停其它所有的工作线程直到收集结束
- 应用：最高的单线程收集效率，Client模式下的默认收集器
- 新生代，复制算法

####3.5.2 ParNew 收集器

-  Serial 收集器的多线程版本
- 多条线程进行垃圾收集
- 并行Parallel：指多条垃圾收集线程并行工作，此时用户线程处于等待状态
- 并发：Concurrent：指用户线程和垃圾回收线程同时执行(不一定是并行，有可能是交叉执行)，用户进程在运行，而垃圾回收线程在另一个 CPU 上运行。
- Server模式下的默认收集器
- 只有Serial、ParNew能和CMS能够配合使用
- 新生代，复制算法

####3.5.3Parallel Scavenge收集器

- 新生代收集器，采用复制算法


- **并行**的多线程收集器


- 目的达到一个可控制的吞吐量
- 新生代，复制算法

####3.5.4 Serial Old收集器

- 单线程
- 使用标记----整理算法
- 主要目的在给client模式下的虚拟机使用
- server模式下用途
  - jdk1.5及其以前的与Parallel Scavenge配合使用
  - 作为CMS的后备预案
- 老年代，标记--整理算法

####3.5.5 Parallel Old收集器

- Parallel Scanvenge的老年代版本
- 使用多线程和标记----整理
- JDK1.6中开始使用
- “吞吐量优先”收集器，在注重吞吐量以及CPU资源敏感的场合，优先考虑Parallel Scavenge、Parallel Old收集器组合

####3.5.6 CMS（Concurrent Mark Sweep）收集器

- 以获取最短回收停顿时间为目标的收集器
- 基于标记--清除算法

**四个步骤**

- 初始标记(CMS initial mark)：标记 GC Roots 能直接关联到的对象
- 并发标记(CMS concurrent mark)：进行 GC Roots Tracing(追踪)
- 重新标记(CMS remark)：修正并发标记期间的变动部3分
- 并发清除(CMS concurrent sweep)

初始标记、重新标记扔“Stop The World”,但是耗时短；

并发标记、并发清理耗时长，但收集器线程可以与用户线程一起工作；

所以，总的来说CMS收集器的内存回收过程是与用户线程一起**并发**的。

优点：并发收集、低停顿

缺点：对CPU资源敏感；无法处理浮动垃圾；空间碎片

####3.5.7G1收集器

面向服务端应用的垃圾收集器

**特点**

- **并行与并发**：多CPU、多核环境，充分缩短停顿时间
- 分代收集
- 空间整合：整体 ”标记--整理“算法，局部（两个Region之间）”复制算法“。
- 可预测的停顿：建立可预测的停顿时间模型。

其他收集器进行收集的范围都是整个新生代或者老年代，而G1把JAVA堆分为多个Region，根据价值大小（回收获得的空间和所需要时间的经验值）回收

如不计算维护 Remembered Set的操作，G1 的步骤为：

- 初始标记：标记一下 GC Root能直接关联到的对象，并修改TAMS的值，停顿
- 并发标记：从GC Root开始对堆中对象进行可达性分析，并发
- 最终标记：修正并发期间导致标记产生变动的那部分标记记录，停顿但并行
- 筛选回收：对各个Region回收价值和成本排序，根据期望的GC停顿时间回收

####3.5.8 GC日志

## 3.6内存回收和分配策略

> 两个问题：给对象分配内存，回收分配给对象的内存

####3.6.1对象优先在Eden区分配

> 大多数情况下，对象在新生代Eden区中分配。当没有足够的Eden时，虚拟机进行一次Minor GC

打印内存回收日志：-XX：PrintGCDetails

- 新生代 GC (Minor GC)：发生在新生代的垃圾回收动作，频繁，速度快。
- 老年代 GC (Major GC / Full GC)：发生在老年代的垃圾回收动作，出现了 Major GC 经常会伴随至少一次 Minor GC(非绝对)。Major GC 的速度一般会比 Minor GC 慢十倍以上。

####3.6.2大对象直接进入老年代

> 大对象：大量连续内存空间的Java对象，如很长的字符串以及数组。经常出现大对象容易导致还有不少空间时就提前触发垃圾收集以获取足够的连续空间

通过设置参数-XX：PretenureSizeThreshold，大于该参数的垃圾收集的时候直接进入老年代，避免在Eden区和两个Survivor进行大量的内存复制

####3.6.3长期存活的对象进入老年代

虚拟机为每个对象定义了年龄计数器，如果对象在Eden区出生，每熬过一次Minor GC，年龄 + 1。

年龄阈值-XX:MaxTenuringThreshold

####3.6.4动态对象年龄判断

为了适应不同内存状况，虚拟机不是必须要求对象年龄达到年龄阈值才晋升老年代。在Survivor区相同年龄大小的所有对象大小的总和大于Survivor的一半，则年龄大于或等于该年龄的对象直接进入老年代

####3.6.5空间分配担保

> 发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立则Minor GC是安全的。不成立则虚拟机会查看 HandlePromotionFailure设置值是否允许担保失败，如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，就尝试进行一次 冒险的Minor GC；如果小于或HandlePromotionFailure
>
> 设置不允许冒险，则改为 Full GC。
>
> 当出现大量对象在Minor GC后仍然存活，就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。

##第四章：虚拟机性能监控与故障处理

![第四章：虚拟机性能监控与故障处理](C:\Users\youngerzeng\Desktop\JavaSE笔记\深入理解Java虚拟机\第4章.jpg)

##第五章：调优案例分析与实战

![第五章：调优案例分析与实战](C:\Users\youngerzeng\Desktop\JavaSE笔记\深入理解Java虚拟机\第5章.jpg)

##第六章：类文件结构

###6.1概述

计算机只能识别0和1

虚拟机以及建立在虚拟机上语言的出现，使编写的程序编译成二进制本地机码（native code）非唯一选择，越来越多编程语言选择了与操作系统和机器指令集无关、平台中立的格式作为程序编译后的存储格式

###6.2无关性的基石

虚拟机可以载入和执行同一种平台无关的字节码

各种平台不同的虚拟机和各个平台统一使用的程序存储格式-字节码（Bytecode），是平台无关性的基石

虚拟机一种中立特性--语言无关性正越来越被重视，基础仍旧是虚拟机和字节码存储格式，虚拟机不和某种语言绑定，只和“Class文件”这种特定的二进制文件相关联，Class文件包含了Java虚拟机指令集和符号表以及其他辅助信息

基于安全性的考虑，Java虚拟机规范要求Class文件中使用许多强制性的语法和结构化约束

###6.3class类文件结构

class文件是以8位字节为基础单位的二进制流，各个数据项按顺序紧密排序，中间没有添加任何分隔符，8位字节以上的数据按高位在前的方式分隔成若干个8位字节进行存储

**class文件格式只有两种数据类型**

**无符号数**

属于基本数据类型，以u1、u2、u4、u8代表1、2、4、8个字节的无符号数

用来描述数字、索引引用、数量值或者按照UTF-8编码构成的字符串

**表**

多个无符号数或者其他表作为数据项构成的复合数据类型

描述有层次关系的复合结构的数据

####6.3.1 魔数与class文件的版本

唯一目的是确定这个文件是否是能被虚拟机接受的class文件

使用魔数而不是扩展名是出于安全考虑，因为扩展名可以随意改动

class文件的魔数：0xCAFEBABF

次版本号

主版本号

####6.3.2常量池

class文件中的资源仓库

常量池容器计数器是从1开始的，且只有常量池计数从1开始

0用来表达“不引用任何一个常量池项目”

**存放两大类常量**

***字面量（Literal）***

接近于java的常量，如文本字符串、声明为final的常量值

**符号引用（Symbolic References）**

- 类和接口的全限定名
- 字段的名称和描述
- 方法的名称和描述

常量池的项目类型

常量项结构1

常量项结构2

####6.3.3访问标志

识别类或者接口层次访问信息

#### 6.3.4类索引、父类索引与接口索引集合

确定类的继承关系

####6.3.5字段表合集

类级变量、实例级变量

字段表结构

描述符的作用是描述字段的数据类型、方法的参数列表（数量、类型以及顺畅）和返回值，基本数据类型和void都用一个大写字母表示，对象类型用L加上对象的全限定名称类表示

不会列出从超类或者继承而来的字段，有可能列出java代码中不存在的字段

#### 6.3.6方法表合集

方法表结构

方法访问标志

#### 6.3.7属性表集合

虚拟机规范预定义的属性

###6.4字节码指令简介

Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（操作么Opscode）以及零至多个代表操作所需参数（称为操作数）而构成

####6.4.1　字节码与数据类型

####6.4.2　加载和存储指令

将数据在栈帧中的局部变量表和操作数栈之间来回传输

####6.4.3　运算指令

两个操作数栈上的值进行某种特定运算，并把结果重写写到操作栈顶

#### 6.4.4　类型转换指令

将两种不同的数值类型进行转换，一般用于显式类型转换

####6.4.5　对象创建与访问指令

####6.4.6　操作数栈管理指令

####6.4.7　控制转移指令

#### 6.4.8　方法调用和返回指令

#### 6.4.9　异常处理指令

#### 6.4.10　同步指令

##第七章：虚拟机类加载机制

###7.1概述

![类的生命周期](C:\Users\youngerzeng\Desktop\JavaSE笔记\img\类的生命周期.png)

> 虚拟机把描述类的数据从class文件加载到内存，经过校验、转换解析、初始化，最形成能够被虚拟机直接使用的java类型，这就是虚拟机的加载过程

类的加载、连接、初始化在运行期进行

动态扩展的语言特性是依赖于运行期动态加载和动态连接这个特点实现的

运行期类加载应用：applet、jsp、osgi

###7.2类的加载时机

> 类的加载、验证、准备和初始化顺序确定，按部就班的开始，而解析不一定：某些情况下在初始化之后，这是为了支持java语言的运行时绑定（也成动态绑定，或者晚期绑定）。互相交叉混合进行

**类的加载时机没有强制约束，有且只有5种情况需要对类初始化（而加载、验证、准备自然需要在这之前）（主动引用）:**

- 遇到new、getstatic、putstatic、invokestatic四条字节码指令时候，如果没有初始化，则需要触发初始化；

  常见的场景：使用new关键字实例化对象、获取或设置类的静态字段（被final修饰，在编译期把结果已经写入常量池的排除）、调用类的静态方法

- 使用java.lang.reflect包的方法对类进行反射调用的时候

- 当初始化一个类的时候，发现父类还没有初始化，则需要先初始化后父类

- 虚拟机启动的时候，用户需要指定一个执行的主类，虚拟机会先初始化这个主类

- 当使用jdk1.7的动态语言支持时，如果一个Java.lang.invoke.MethodHandle实例解析的结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这些方法句柄对应的类没有实例化，则需要先初始化

**所有引用的方式都不会触发初始化，称为被动引用**

- 通过子类调用父类静态字段，不会导致子类初始化
- 通过数组定义类引用类，都不会触发此类的初始化
- 常量在编译期被存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发初始化
- 接口与类的差异：初始接口的时候，并不要求其父类接口全部初始化，只有真正使用父类接口的时候才会初始化

###7.3类的加载过程

####7.3.1加载

**在加载阶段，虚拟机需要完成3件事情**

- 通过一个类的全限定名来获取定义该类的二进制字节流
- 将这个字节流代表的静态存储结构转化为方法区的运行时数据结构
- 在内存中生成代表该类的java.lang.Class对象（没有明确规定在Java堆上，对于hotSpot虚拟机，Class对象比较特殊，虽然是对象，存放在方法区），作为方法区这个类各种数据的访问入口

**二进制流的获取**

- 从zip包获取，最终成为日后jar、ear、war格式的基础
- 从网络获取，这种场景最典型的应用就是applet
- 运行时计算机生成，使用最多的就是动态代理
- 由其他文件生成，典型的应用jsp，即由jsp生成对应的类
- 从数据库获取,场景比较少见，有些中间件（SAP Netweaver）可以选择把程序安装到数据库来完成程序代码在集群间的分发

... ...

一个**非数组类**的加载，是开发人员可控性最强的，可以自定义类加载器，定义自己的类加载器控制字节流的获取方式

**数组类**本身不是通过类加载器创建，是由Java虚拟机直接创建，创建数组需要遵循的规则如下：

- 如果组件类型是一个引用类型，递归采用加载过程去加载这个组件类型，数组将在加载该组件类型的类加载器的类名称空间上标识
- 如果组件类型非引用类型，将会把数组标记为与引导类相关联
- 数组类的可见性和他的组件类可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public

加载阶段和连接阶段的部分内容是交叉进行的

#### 7.3.2验证

> 验证的目的是为了确保class文件字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全，防止恶意代码攻击

**四个阶段的检验过程**

**1.文件格式验证**

- 是否已魔数0xCAFEBABF开头
- 主、次版本号是否在当前虚拟机处理范围
- 常量池的常量是否有不被支持的常量类型
- 指向常量的各种索引值中是否有指向不存在或者不符合类型的常量
- CONSTACT_Utf8_info型的常量是否有不符合utf8编码的数据
- Class文件中各个部分及文件本身是否有被删除或者附加其他信息

......

是否符合Class文件格式规范，且能够被当前版本虚拟机处理；保证输入的字节流能够被解析并存储于方法区之内，后面的三个阶段是基于方法区存储结构进行的，不会直接操作二进制流

**2.元数据校验**

- 这个类是否有父类（除Object类以外，其他类都应该有父类）

- 父类是否继承了不允许被继承的类（被final修饰的类）

- 如果类不是抽象类，是否实现了其父类或者接口中要求实现的方法

- 类中的字段、方法是否与父类产生矛盾（例如覆盖父类的final字段，或不符合规则的冲则）

  ......

对字节码的描述信息（元数据）进行语义分析，保证描述的信息符合Java语言规范要求

**3.字节码校验**

- 保证任意时刻的数据栈的数据类型与指令代码序列都能配合执行（例如不会出现
- 操作数栈放置了int类型数据，使用时却按long类型加载到本地变量表中）
- 保证跳转指令不会调到方法体以外的字节码指令上
- 保证方法体的类型转换时有效的
- 通过数据流和控制流确定程序语义是合法的、符合逻辑的；对类的方法体进行校验分析，
- 保证被校验类的方法在运行期间不会做出危害虚拟机的事情

**4.符号引用验证**

- 符号引用中通过字符串的全限定名能否找到对应的类
- 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的字段和方法
- 符号引用中的类、字段、方法的访问性是否可以被当前类访问

... ...

发生在将符号引用转换为直接引用的时候，对类信息以外的的信息进行匹配校验；

保证解析动作能够正常执行

验证阶段是非常必要的，但不是必须的

#### 7.3.3准备

> 为**类变量**分配内存并设值初始值；变量所使用的内存都在方法区上分配

> 通常情况下初始为零值，如果字段属性表中存在ConstantValue属性，则被初始化ConstantValue指定的值

####7.3.4解析

>  将常量池中的符号引用替换为直接引用的过程

- 符号引用：以一组符号来描述所引用的对象，符号可以是任意形式的**字面量**，只要使用时能无歧义的定位到目标即可，与虚拟机实现布局无关，引用的目标不一定加载到内存


- 直接引用：直接指向目标的**指针**、**相对偏移量**或者一个能够间接定位目标的的**句柄**，与虚拟机布局相关

1. 类或接口解析
2. 字段解析
3. 类方法解析
4. 接口方法解析

#### 7.3.5类初始化

> 初始化过程是执行类构造器()<clinit>()的过程

clinit()方法执行过程中可能影响的程序运行特点和细节:

- 由编译器自动收集类中的所有类变量赋值动作和静态语句块中的语句合并产生的，编译收集顺序由语句在源文件的顺序决定，静态语句块中只能访问到定义在语句块之前的变量，定义在他后的变量，可以赋值，但不能访问
- 和实例构造器init()不同，不需要显式的调用父类构造器，虚拟机会保证在子类clinit()方法执行之前，父类的已经执行完毕
- 父类中定义的静态语句块要优先于子类的变量赋值操作
- 对于类或者接口不是必须的
- 接口中没有静态语句块，但仍有变量初始化的赋值操作，因此会生成clinit()方法，但与类不同，执行接口的()方法不需要先执行父接口的()方法，只有父接口变量使用时，才初始化虚拟机保证一个类的clinit()方法在多线程环境中被正确加锁、同步

###7.4类加载器

####7.4.1类与类加载器

>  类加载器只用于类加载动作

对于任意一个类，都需要由加载他的类加载器和类本身确立其在Java虚拟机中的唯一性

每个类加载器，都有独立的命名空间

比较两个类”相等“，只有在同一个类加载器加载的前提下才有意义

####7.4.2双亲委派模型

**三种系统提供的类加载器**

- **启动类加载器**：加载 lib 下或被 -Xbootclasspath 路径下的类 ,C++实现
- **扩展类加载器**：加载 lib/ext 或者被 java.ext.dirs 系统变量所指定的路径下的类，开发者可以直接使用
- **应用程序类加载器**：加载用户类路径（Classpath）上指定的类库，开发者可以直接使用

如果没有自定义类加载器，一般情况这个就是程序默认类加载器

![类加载器双亲委派模型](C:\Users\youngerzeng\Desktop\JavaSE笔记\img\类加载器双亲委派模型.png)

图中展示的类加载器的这种层次关系，称为类加载器的**双亲委派模型**

双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都需要有自己的父类加载器

类加载的父子关系一般不会以继承的关系来实现，而是使用组合关系来复用父加载器

**加载过程**：如果一个类加载收到类加载请求，先不会自己去处理，而是委托父类加载器去完成，依次递归，因此所有加载请求最终都应该传送到启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子类才会去尝试加载

一个显而易见的好处Java类随着类加载器一起具备了一种带有优先级的层次关系

保证java程序的稳定性

解决了各个类加载器基础类的统一问题

#### 7.4.3破坏双亲委派模型

**3次大破坏**

发生在双亲委派模型出现之前，JDK1.2发布之前

自身缺陷造成（基础类调用用户代码,怎么办？SPI，Service Provider Interface加载，例如JNDI、JDBC、JCE、JAXB、JBI），线程上线文类加载器

由于用户追求程序的动态性（代码热替换、模块热部署）造成的

##第八章：虚拟机字节码执行引

###8.1概述

>  执行引擎：输入字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果

###8.2运行时栈帧结构

> 栈帧：是虚拟机用于**方法调用**和**方法执行**的数据结构，是虚拟机运行时数据区的虚拟机栈的栈元素

栈帧存储了方法的**局部变量表**、**操作数栈**、**动态连接**、**方法返回地址**等信息

每一个方法从调用开始到执行结束，就是栈帧在虚拟机栈中入栈出栈的过程

在编译期间，栈帧需要多大的局部变量表、多深的操作数栈都已经完全确定，并且写入方法的code 属性中

在活动线程中，栈顶的栈帧才是有效的，称为**当前栈帧**，相关联的方法称为**当前方法**

####8.2.1局部变量表

> 是一组变量值存储空间，用于存放**方法参数**和方法内部定义的**局部变量**

在Java程序编译为class时，就在方法的code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量

局部变量表的容量以**变量槽slot**为最小单位

一个slot可以存放一个32位以内的数据，Java中32位以内的数据类型有：boolean、byte、char、short、int、float、reference、returnAddress

通过**Reference类型**可以：

- 从此引用直接或者间接的获取到对象在堆上存放的起始地址索引
- 此引用中直接或者间接的查找到对象所属数据类型在方法区的存储类型信息

对于64位（long，double）的数据类型，虚拟机采用高位对齐的方式为其分配两个slot空间

虚拟机通过索引定位的方式使用局部变量表

方法执行过程中，虚拟机通过局部变量表完成变量值到参数列表的传递过程

对于实例方法，局部变量表中第0位索引的slot默认传递方法所属对象实例的引用

为了节省栈帧空间，slot空间可以重用，但是会有额外的副作用，例如影响垃圾收集

####8.2.2操作数栈（操作栈）

是一个后入先出栈

在编译时候写入code属性的max_stacks数据项中

操作数栈的每一个元素可以是任意的Java数据类型

32位数据类型占用的栈容量为1,64位数据类型占用的栈容量为2

操作数栈中元素的数据类型和字节码指令的序列严格匹配

概念模型上，两个栈帧完全相互独立，但大多虚拟机做了优化处理，使两个栈帧出现一部分重叠（方法调用可以共用一部分数据，无需进行额外的参数复制传递）

####8.2.3动态连接

每个栈帧都有一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接

####8.2.4方法返回地址

正常完成出口：PC计数器的值可以作为返回地址，栈帧中很可能保存这个计数值

异常完成出口：通过异常处理器表来确定返回地址，栈帧中一般不会保存这部分信息

方法退出等同于当前栈帧出栈，可能执行的操作有：

恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令

###8.3方法调用

> 方法调用不等同于方法执行，唯一任务就是**确定被调用方法的版本**

####8.3.1解析

> 调用目标在程序写好、编译器进行编译时就必须确定下来，这类方法的调用称为解析

所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用。

编译期可知，运行期不变的方法：静态方法、私有方法

相对应的5条方法调用字节码指令

- invokestatic：调用静态方法
- invokespecial：调用实例构造器init方法、私有方法、父类方法
- invokevirtual：调用所有的虚方法
- invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象
- invokedynamic：现在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法

只要能被invokestatic和invokespecial指令调用的方法，都可以再解析阶段中确定唯一的调用版本，符合这个条件的由静态方法、构造方法、私有方法、父类方法四大类，这些方法称为非虚方法（还包含final修饰的方法，无法被覆盖，没有其他版本）；与之相反的称为虚方法（final修饰除外）

####8.3.2分派（重载、重写）

**静态分派（重载）**

静态类型（外观类型）：变量本身的静态类型不会被改变，最终的静态类型是在编译期可知的

实际类型：变化结果在运行期才确定

使用哪个版本的重载，完全取决于传入参数的数量和数据类型；虚拟机（准确的说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据；并且静态类型是编译期可知的，因此，在编译阶段，javac编译器会根据参数的静态类型决定使用哪个版本的重载

所有依赖静态类型来定位方法执行版本的分派称为静态分派

静态分派的典型应用就是方法重载

**动态分派（重写）**

**invokevirtual的运行时解析过程：**

找到操作数栈顶的第一个元素指向的对象的实际类型，记作C

如果类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束，如果不存在，则返回java.lang.IllegalAccessError异常

否则，按照继承关系从下往上依次对C的各个父类进行第二步的查搜索和验证过程

如果始终没有找到，则抛出java.lang.AbstractMethodError异常

运行期根据实际类型确定方法版本的分派称为动态分派

**单分派和多分派**

方法的接受者方法的参数统称为方法的宗量，根据分派基于多少种宗量，可以将分派划分为单分派和多分派

单分派是根据一个宗量对目标方法进行选择

多分派是根据多于一个宗量对目标方法进行分派

静态分派属于多分派

动态分派属于单分派

虚拟机动态分派的实现

方法表

####8.3.3动态类型语言支持

**动态类型语言**

关键特征是类型检查的主体过程是在运行期而不是编译期

变量无类型而变量值有类型

静态类型语言在编译期提供严谨的类型检查

动态类型语言提供了更大的灵活性

**JDK7与动态类型语言**

invokedynamic指令以及java.lang.invoke包出现

**java.lang.invoke包**

提供了一种动态确定目标方法的机制，称为MethodHandle

MethodHandle和反射（Reflection）区别：

本质上将都是在模拟方法调用，但反射模拟Java代码层次的调用，MethodHandle模拟字节码层次的调用

反射中的java.lang.Method对象远比MethodHandle机制的java.lang.MethodHandle对象所彪悍的信息多，反射是重量级，MethodHandle是轻量级

MethodHandle优化

**invokedynamic指令**

每一处含有invokedynamic指令的地方都称为动态调用点

**掌控方法分派规则**

## 8.4基于栈的字节码解释执行引擎

####8.4.1解释执行

javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，在遍历语法树生成线性的字节码指令流的过程

一部分在虚拟机之外进行，而解释器是在虚拟机内部，所以Java程序的编译是半独立的实现

####8.4.2基于栈的指令集和基于寄存器的指令集

基于栈的指令集主要优点是可移植性、代码更加紧凑、编译实现更简单；缺点是执行速度相对慢点

####8.4.3基于栈的解释器执行过程

##第九章：类加载及其执行子系统的案例与实战

###9.1概述

在class文件格式和执行引擎这部分内容中，用户程序能直接影响的并不多，Class文件以何种形式存储，类型何时加载、如何连接，以及虚拟机如何执行字节码指令都由虚拟机直接控制，用户无发改变；能够通过程序控制的，主要是字节码生成和类加载器两部分

###9.2案例分析

####9.2.1Tomcat：正统的类加载架构

一个功能健全的web服务器需要解决的问题

同一个web服务器上的不同应用程序可以实现相互隔离

同一个web服务器上的不同应用程序可以实现共享

服务器尽量保证自身安全不受部署应用程序的影响

支持jsp应用的web服务器，大多数需要支持HotSwap功能

####9.2.2：OSGI：灵活的类加载架构

OSGI(Open Service Gateway Initiative)：基于Java语言的动态模块化规范

典型应用：Eclipse Idea

OSGI的每个模块成为Bundle

##第十章：早期（编译器）优化

###10.1概述

Java语言的“编译期”其实是个“**不确定**”的过程：

前端编译器：把Java文件编译成class文件，例如Sun的javac、Eclipse JDT中的增量编译器（ECJ）

后端编译器（JIT编译器，just in time compiler）：把字节码转换为机器码，例如HotSpotVM的C1、C2编译器

静态提前编译（AOT编译器，Ahead Of Time compiler）：把Java直接编译为本地机器代码，例如：GNU Compiler for the Java(GCJ)，Excelsior JET

本章提到的“编译器”和“编译期”指的是前端编译

javac做了许多针对Java语言编码过程的优化措施来改善程序员的编码风格和提高编码效率

即时编译器在运行期优化更重要，前端编译器对于程序编码来说关系更密切

###10.2javac编译器

####10.2.1Javac的源码和调试

**编译的过程：**

解析与填充符号表过程

插入式注解处理器的注解过程

分析与字节码生成过程

####10.2.2解析与填充符号表

解析过程由parseFiles()方法完成，包含经典编译原理中的词法分析和语法分析

*a>词法分析、语法分析*

词法分析是将源代码的字符流转变为标记（Token）集合

词法分析由com.sun.tools.javac.parser.Scanner类实现

语法分析是根据Token序列构造抽象语法树的过程

语法分析由com.sun.tools.javac.parser.Parser类实现

抽象语法树（Abstract Syntax Tree,AST）是一种描述程序代码语法结构的树形式表现，每个节点代表程序中的语法结构（Construct），例如包、

类型、修饰符、运算符、接口、返回值甚至代码注释都可以作为语法结构

语法抽象树由java.sun.tools.javac.tree.JCTree表示

后续的操作都建立在语法树上

*b>填充符号表*

由enterTrees()方法完成

**符号表**（Symbol Table）是由一组符号地址和符号信息构成的表格

符号表中所登记的信息在编译的不同阶段都会用到，在语义分析中，用于语义检查和产生中间代码；在目标代码生成阶段，符号表是地址分配的

依据

过程由java.sun.tools.javac.comp.Enter类实现，出口是一个待处理列表

####10.2.3注解处理器

注解与普通Java代码一样，在运行期发挥作用

jdk1.6提供了插入式注解处理器标准API在编译期间对注解进行处理，可以读取、添加、修改抽象语法树的任意元素

处理注解期间对语法树进行修改，编译器将进入解析与填充符号表阶段重新处理

初始过程由initProcessAnnotations()方法完成

#### 10.2.4语义分析与字节码生成

语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查

*a>标注检查*

变量使用前是否被声明

变量与赋值之间的数据类型是否匹配

...

*b>数据及控制流分析*

对上下文逻辑的进一步校验

**可以检查出**

局部变量在使用前是否赋值

方法的每条路径是否有返回值

是否所有的受检异常都正确处理

...

*c>解语法糖*

语法糖：计算机语言中添加的某种语法，这种语法对于语言的功能并没有影响，但是更方便程序员使用

语法糖能够增加程序的可读性，从而减少程序代码的出错机会

Java语言中语法糖主要有：泛型，变长参数，自动装箱/拆箱

解语法糖：虚拟机运行时不支持语法糖，它们在编译阶段还原回简单的基础语法结构

*d>字节码生成*

将前面各个步骤生成的信息（语法树、符号表）转换为字节码写到磁盘中，还进行了少量的代码添加和转换工作

代码添加：实例构造器和类构造器在这个阶段添加到语法树

代码转换：字符串加操作替换为StringBuffer或者StringBuilder

###10.3Java语法糖的味道

语法糖不会提供实质性的功能改进，但是或许能够提高效率、提升语法严谨性、减少编码出错的机会

#### 10.3.1泛型与类型擦除

泛型的本质是参数化类型（Parametersized Type）的应用，也就是说所操作的数据类型被指定为一个参数

Java语言中的泛型只在源码中存在，在编译后的字节码中，就已经替换为原来的原生类型（Raw Type，也称为裸类型），所以泛型是java语言的一颗语法糖，Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型

引入Signature、LocalVariableTable等属性用于解决伴随泛型而来的参数化类型的识别

Signature：作用是存储一个方法在字节码层面的特征签名，保存的类型不是原生类型，而是包含了参数化类型的信息

擦除法所谓的擦除，仅仅是对方法的code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能够通过反射手段获取到参数化类型的根本依据

#### 10.3.2自动装箱、拆箱与遍历循环

自动装箱、拆箱在编译后转换成了对应的包装和还原方法

遍历循环把代码还原成了迭代器的实现，所以被遍历的类需要实现Iterable接口

包装类的“==”运算在不遇到算出运算的情况下不会自动拆箱

包装类equals()方法不处理数据转型的关系

#### 10.3.3条件编译

Java进行条件编译的方式是使用条件为常量的if语句

##第十一章：晚期（运行期）优化

###11.1概述

为了提高热点代码的运行效率，在运行时，虚拟机会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler ，JIT编译器）

java虚拟机规范中没有约束JIT的应该如何实现，所以这部分功能完全是与虚拟机具体实现相关的内容

### 11.2HotSpot虚拟机即时编译器

**需要解决的问题**

为何HotSpot虚拟机要使用解释器和编译器共存的架构？

为何HotSpot虚拟机要实现两个不同的即时编译器？

程序何时使用解释器执行？何时使用编译器执行？

哪些程序会被编译成本地代码？如何编译为本地代码？

如何从外部观察即时编译器编译过程和编译结果？

####11.2.1解释器和编译器

**解释器和编译器各自优势**

解释器：程序可以迅速启动和执行，省去编译时间；内存限制较大时，可以节约内存；可以作为编译器激进优化的“逃生门”

编译器：编译成本地代码，提升运行效率

HotSpot内置C1和C2两个即时编译器，使用哪个编译器取决于虚拟机运行模式

可以强制设置虚拟机只是用解释器和编译器中的一种

**分层编译（为了启动和运行达到平衡）**

第0层，程序解释执行，解释器不开启性能监控功能（Profiling），可触发第一层编译

第1层，也成C1编译，将字节码编译为本地代码，进行简单、可靠优化，如有必要加入性能监控的逻辑

第2层（或2层以上），也成C2编译器，将字节码编译为本地代码，但是会启动一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化

实时分层后，C1和C2将会同时工作，许多代码可能会被编译多次，C1获取更高的编译速度，C2获取更好的编译质量，在解释执行的时候也无需承担性能监控信息的任务

####11.2.2编译对象与触发条件

**热点代码：**

- 被多次调用的方法：整个方法作为编译对象，标准的JIT编译方式
- 被多次执行的循环体：依然会以整个方法作为编译对象，编译发生在方法执行过程中，称为栈上替换（On Stack Replacement，OSR编译）

**热点探测：**

> 判断一段代码是不是热点代码，需不需要触发及时编译的行为称为热点探测（Hot Spot Detection）

**探测方式：**

- 基于采样的热点探测

周期性的检查栈顶，某个方法经常出现在栈顶，说明是热点方法

优点：简单、高效、可以容易的获取方法调用关系

缺点：很难精确的确认一个方法的热度，容易受到线程阻塞或者其他外界因素的影响而扰乱热点探测

- 基于计数器的热点探测

为每个方法建立一个计数器，统计方法执行的次数，执行次数超过某个阈值就认为他是热点方法

缺点：实现麻烦，不能直接获取方法调用关系

统计结果更加精准、严谨

HotSpot采用基于**计数器的热点探测**

**每个方法有两个计数器**

**方法调用计数器**

可设定阈值

如果不设定，计数器的次数不是绝对值，是一个相对频率，即一段时间内调用的次数

超过一段时间仍未提交即时编译器处理，方法调用计数器热度衰减(一般)，这个时间称为半衰周期，在垃圾收集的时候进行

可以设定绝对次数

**回边计数器**

统计方法体中循环体执行的次数

为了触发OSR编译

####11.2.3编译过程

**C1编译器**

简单快速的三段式编译，局部优化

第一阶段，一个平台独立的前度将字节码构造成一种高级中间代码表示（HIR）。HIR使用静态单分配的形式来代表代码值

第二阶段，一个平台相关的后端从HIR中产生低级代码表示LIR

最后阶段，平台相关的后端使用线性表扫描法在LIR上分配寄存器，并在LIR上最窥孔优化，然后生成及其代码

**C2编译器**

会执行所有的典型优化

实施一些和Java语言特性密切相关的技术

根据解释器或者C1提供性能监控，提供不稳定的激进性能优化

## 第十二章：Java内存模型与线程

###12.1概述

衡量一个服务端的好坏，每秒事物处理数（Transactions Per second，TPS）是最重要的指标之一

###12.2硬件的效率与一致性

基于高速缓存的存储交互很好的解决了处理器与内存的速度矛盾，但是也为计算机系统带来了更高的复杂性，引入了新的问题：缓存一致性

为了使处理器内部运算单元尽量充分利用，处理器会对输入代码乱序执行优化

Java 虚拟机的即时编译器中也有类似的指令重排序优化

###12.3 Java内存模型

> Java虚拟机规范定义了一种内存模型（JAVA Memory Model，JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现Java语言在各个平台都能达到一致的内存访问效果

![线程、主内存、工作内存的交互关系](C:\Users\youngerzeng\Desktop\JavaSE笔记\img\线程、主内存、工作内存的交互关系.png)

####12.3.1主内存和工作内存

Java内存模型的**主要目标**是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节，此处的变量和Java编程中所说的有所区别，它包括实例变量、静态字段、和构成数组对象的元素，但是不包括局部变量和方法参数，后者是线程私有的，不会被共享，自然就不会存在竞争问题

Java内存模型规定了所有的变量都存储在主内存（Main memory）中，每条线程还有自己的工作内存（Working Memory），线程的工作内存保存了被该线程使用的变量的主内存副本拷贝

线程对变量的操作（读取、赋值）必须都在工作内存中进行，而不能直接读写主内存中的变量

不同的线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递都通过主内存传递

#### 12.3.2内存间交互操作

关于主内存与工作内存之间的交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存，Java内存模型定义了8种操作来完成；每一种操作都是原子的、不可再分的（long和double有例外）

- **lock(锁定)**：作用于**主内存**变量，把一个变量状态标识一条线程独占的状态
- **unlock(解锁)**：作用于**主内存**变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
- **read(读取)**：作用于**主内存**变量，把一个变量的值从主内存传输到工作内存中，以便随后的load动作使用
- **load(载入)**：作用于**工作内存**变量，把read操作从主内存得到的变量值放入工作内存的变量副本中
- **use(使用)**:作用于**工作内存**变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令的时候都会执行这个操作
- **assign(赋值)**:作用于**工作内存**，把执行引擎返回的结果值赋给工作内存的变量
- **store(存储)**:作用于**工作内存**的变量，把工作内存中的一个值传递到主内存中去，以便随后的write操作
- **write(写)**:作用于**主内存**变量，把store操作从工作内存中等到的变量值放到主内存的变量中去

执行8中操作时候必须满足的**规则**

- 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了，在工作内存不接受，或者从工作内存发起回写，主内存不接受的情况
- 不允许一个线程丢弃掉它最近的assign操作，即变量在工作内存改变以后必须把该变化同步到主内存
- 不允许一个线程无原因的（没有发生过任何assign）把数据从工作内存同步到主内存
- 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或者assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过assign和load操作
- 一个变量在同一时刻只能有一个线程对其进行lock操作，但是lock操作可以被同一线程重复执行多次，多次lock执行后，只有执行相同次数的unlock操作，变量才会被解锁
- 如果对变量执行lock操作，将会清空工作内存此变量的值，在执行引擎使用这个变量钱前，需要重新load或者assign初始化变量的值
- 如果一个变量事先没有被lock，就不允许执行unlock操作，也不允许unlock一个被其他线程lock的变量
- 对一个变量unlock之前，必须把此变量同步到主内存

先行发生原则：用来确定一个访问在并发环境下是否安全

#### 12.3.3对于volatile型变量的特殊规则

Java虚拟机提供的轻量级同步机制

**作用：**

- 保证此变量对所有线程的可见性

不存在一致性问题

Java语言里的运算并非原子性，导致volatile变量的运算在并发下是安全的

在不符合以下两条规则的场景中，仍要通过加锁（使用synchronize或java.util.concurrent中的原子类）来保证原子性

> 运算结果并不依赖于变量的当前值，或者能够确保只有单一的线程修改变量的值

> 变量不需要与其他的状态变量共同参与不变约束

- 禁止指令重排序优化

特殊规则

每次使用Volatitle变量前必须先从主内存刷新最新的值

工作内存中修改volatile变量后必须同步到主内存中

volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序和代码顺序一致

#### 12.3.4对于long和double型变量的特殊规则

允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机不保证64位数据类型的load、store、read和write这4个操作的原子性，这就是long和double的非原子性协定

目前商业虚拟机不会出现读取到“半个变量"的情况

#### 12.3.5原子性、可见性、有序性

原子性

- 基本数据类型的访问读写是具备原子性（例外是long和double的非原子性协定）
- synchronized块之间的操作具备原子性

可见性

当一个线程修改变量的值，其他线程能够立刻得知这个修改

synchronized、volatile、final都能保证可见性

有序性

如果在本线程内观察，所有的操作都是有序的，如果在一个线程中观察另一个线程，所有操作都是无序的

synchronized、volatile保证有序性

#### 12.3.6先行发生原则

- 程序次序规则：按程序代码顺序
- 管程锁定规则：unlock优先于后面对同一个锁的lock操作
- volatile变量规则：写优先于后面对这个变量的读操作
- 线程启动规则：start()方法先行于每个动作
- 线程终止规则：线程中所用操作先行于对此线程的终止检测
- 线程中断规则：对线程的interrupt()方法的调用优先发生于被中断线程的代码检测到的中断事件的发生
- 对象终结规则：初始化先行发生于finalize()
- 传递性

###12.4Java与线程

####12.4.1线程的实现

**3种方式：**

1. **使用内核线程实现**

直接由操作系统内核支持的线程，由内核完成线程切换，内核通过操纵调度器进行线程调度，并且负责将线程的任务映射到各个处理器上

程序一般不会直接使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Light Weight Process ，LWP），轻量级进程就是我们通常意义上讲的线程

轻量级进程和内核线程之间1:1的关系称为一对一线程模型

![内核线程](C:\Users\youngerzeng\Desktop\JavaSE笔记\img\内核线程.png)

轻量级进程的局限性

- 基于内核实现，各种线程操作需要进行系统调用，而系统调用的代价相对较高，需要在用户态（User Model）和内核态（Kernel Model）中来回切换
- 每个轻量级进程都需要一个内核线程支持，轻量级进程要消耗一定的内核资源，因此一个系统支持轻量级进程的数量是有限的

2. **使用用户线程实现**

狭义的用户线程指的是完全建立在用户空间的线程库，系统内核不能感知线程存在

进程与线程之间的1：N的关系称为一对多的线程模型

优势在于不需要内核支援，劣势也在于没有内核支援

实现比较复杂，使用用户线程的程序越来越少

![用户线程](C:\Users\youngerzeng\Desktop\JavaSE笔记\img\用户线程.png)

3. **使用用户线程加轻量级进程实现**

用户线程完全建立在用户空间，用户线程的创建、切换、析构的操作比较廉价，并且支持大规模的用户线程并发

操作系统提供支持的轻量级进程则作为用户线程和内核线程的桥梁

使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险

![用户线程加轻量级线程混合](C:\Users\youngerzeng\Desktop\JavaSE笔记\img\用户线程加轻量级线程混合.png)

####12.4.2Java线程调度

线程调度是指系统为线程分配处理器使用权的过程

**两种主要调度方式:**

1. 协同式线程调度

执行时间由线程本身决定，执行完后，主动通知系统切换到另一个线程

好处是实现简单；切换操作对线程自己可知，所以没有什么同步问题；

坏处是执行时间不可控；可能会出现程序一直阻塞的情况

2. 抢占式线程调度

线程由系统分配执行时间，切换不由线程本身决定

执行时间系统可控，不会有一个线程导致整个进程阻塞的情况

Java使用的线程调度方式是抢占式线程调度

建议给系统分配时间：线程优先级

#### 12.4.3状态转换

**5种状态：**

**新建（New）**：创建后尚未启动

**运行（Runable）**：包括操作系统线程状态中的Running和Ready，也就是正在执行和等待CPU为它分配执行时间的

**无限期等待（Waiting）**：不会被CPU分配时间，要等待被其他线程显式地唤醒

- 没有设置Timeout参数的Object.wait()
- 没有设置Timeout参数的Thread.join()
- LockSupport.park()

**限期等待（Timed Waiting）**：不会被CPU分配时间，一定时间后会自动唤醒

- Thread.sleep()
- 设置Timeout参数的Object.wait()
- 设置Timeout参数的Thread.join()
- LockSupport.paNanos()
- LockSupport.parkUntil

**阻塞（Blocked）**：线程被阻塞

“阻塞状态”和“等待状态”的区别:

- “阻塞状态”在等待一个排它锁
- “等待状态”实在等待一段时间或者唤醒动作的发生

结束（Terminated）：已终止的线程状态，线程已经执行结束

##第十三章：线程安全与锁优化

###13.1概述

###13.2线程安全

> 当多个线程访问一个对象的时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的

####13.2.1Java语言中的线程安全

1. **不可变**

在Java语言里（特指JDK1.5以后），不可变（Immutable）的对象一定是线程安全的

不可变带来的线程安全是最简单和最纯粹的

如果共享数据是基本类型，只要定义时final修饰就可以保证不可变；

如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行

把对象带有状态的变量都声明为final

符合不可变数据类型：String，枚举类型，java.lang.Number的部分子类（Long和Double数值的包装类型，BigInteger和Bigmal等大数据类型）

2. **绝对线程安全**
3. **相对线程安全**

通常意义上将的线程安全，需要保证对这个对象的单独操作是线程安全的，我们在调用的时候不需要做额外的保障措施；

对于一些特定顺序的连续调用，就可能需要调用端使用额外的同步手段来保证调用的正确性

大多数线程安全的类属于这种类型，例如Vector、hashTable、Collections的synchronizedCollection()包装的集合等

4. **线程兼容**

对象本身并不是线程安全，但是可以通过调用端正确的使用同步手段来保证在并发环境中可以安全使用

5. **线程对立**

无论调用端是否采用同步手段，都无法再多线程环境中使用的代码

Thread类的suspend和resume方法

System.setIn()、System.setOut、System.runFinalizersOnExit

####13.2.2线程安全的实现方式

1. **互斥同步（阻塞同步）**

常见的一种并发正确性的保障手段

同步指多个线程并发访问共享数据时，保证贡献数据在同一时刻只能被一个（或者是一些，使用信号量的时候）线程使用

互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是互斥的实现方式

互斥是因，同步是果；互斥是方法，同步是目的

**synchronized关键字**

最基本的互斥同步手段就是synchronized关键字

synchronized关键字在编译后会生成monitorenter和monitorexit两条字节码指令，两条指令都需要一个reference类型的参数作为锁定和解锁的对象。如果明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就是根据修饰的是实例方法还是类方法，去取对应的对象实例或者Class对象作为锁对象

synchronized对同一个线程来说是可重入的；同步块在已进入的线程执行完之前，会阻塞后面的线程

**java.util.concurrent包中的ReentrantLock**

- 等待可中断：当持有锁的线程长期不释放锁的时候，等待的线程可以放弃等待，改为处理其他事情
- 公平锁：多个线程等待同一个锁，必须按照申请锁的时间来依次获得锁，默认是非公共锁，可以通过参数使用
- 锁绑定多个条件：可以同时绑定多个Condition对象

进行线程阻塞和唤醒带来性能问题；一种悲观的并发策略；

2. **非阻塞同步**

阻塞同步：互斥同步主要问题是进行线程阻塞和唤醒所带来的性能问题，这种同步称为阻塞同步。是一种悲观的并发策略，无论共享数据是否真的会出现竞争，都要加锁

非阻塞同步：基于冲突检测的乐观并发策略，先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施，这种同步称为非阻塞同步

操作和冲突检测这两个步骤要具备原子性

**通过处理器指令来完成**

- 测试并设置（Test-and-Set）
- 获取并增加（Fetch-and-Increment）
- 交换（Swap）
- 比较并交换（Compare-and-Swap，CAS）
- 加载链接/条件存储（Load-Link/Store Conditional，LL/SC）

3. **无同步方案**

天生线程安全的

**可重入代码（Reentrant Code）**

如果一个方法，它的返回值是可以预测的，输入相同数据就能返回相同结果

**线程本地存储（Thread Local Storage）**

大部分使用消费队列的架构模式都会将产品的消费过程尽量在一个线程中完成

应用实例：经典的web交互模型（一个请求对应一个服务器线程）

Java.lang.ThreadLocal

13.3锁优化

为了在线程间更高效的共享数据，以及解决竞争问题，从而提高程序的执行效率

####13.3.1自旋锁和自适应自旋

> 自旋锁：让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。

锁占用时间少，效果非常好；反之，白白的消耗处理器资源，反而带来性能浪费。

因此，给自旋限定次数，超过次数没有成功获得锁就挂起线程，默认10次，可通过

参数-XX：PreBlockSpin来更改

**自适应的自旋锁**：自旋时间不固定，由前一次在同一个锁上的自旋时间及锁的拥有者状态决定。

####13.3.2锁消除

> 即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除

有许多同步措施并不是程序员自己加入

####13.3.3锁粗化

> 问题：一般尽量把同步块的作用范围限制的尽量小，只在共享数据的实际作用域中才进行同步，这样是为了等待锁的线程也能尽快拿到锁。
>
> 但如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中，那即使没有线程竞争，频繁进行同步操作会导致不必要的性能损耗

锁粗化：如果虚拟机探测到一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。

如StringBuffer的append()方法反复使用，就会扩展到第一个append()操作之前到最后一个append()操作之后，这样只需加一次锁就好了。

#### 13.3.4轻量级锁

> 传统的锁机制称为“重量级”锁
>
> 目的：本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗

####13.3.5偏向锁

> 目的：消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。
>
> 如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。







[java虚拟机原理图解](https://blog.csdn.net/column/details/jvm-principle.html)